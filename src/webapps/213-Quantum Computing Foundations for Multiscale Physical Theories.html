<html><head><base href="https://quantum-string-orchor.edu/"><title>Quantum Computing Foundations for Multiscale Physical Theories</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f8ff;
    }
    h1, h2 {
        color: #1c4f82;
    }
    .interactive-chart {
        width: 100%;
        height: 400px;
        margin: 20px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #fff;
    }
    .navigation {
        display: flex;
        justify-content: space-between;
        margin-top: 40px;
    }
    .nav-button {
        padding: 10px 20px;
        background-color: #1c4f82;
        color: #fff;
        text-decoration: none;
        border-radius: 5px;
    }
</style>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
</head>
<body>
    <h1>Quantum Computing Foundations for Multiscale Physical Theories</h1>
    
    <p>Welcome to the second installment of our series exploring the intersection of quantum computing, string theory, and Orchestrated Objective Reduction (Orch-OR) theory. In this section, we'll delve into the fundamental concepts of quantum computing and how they provide a robust framework for understanding and simulating multiscale physical theories.</p>
    
    <h2>1. Quantum Bits and Superposition</h2>
    <p>At the heart of quantum computing lies the quantum bit, or qubit. Unlike classical bits, qubits can exist in a superposition of states, allowing for the representation of multiple possibilities simultaneously.</p>
    
    <div id="qubit-bloch-sphere" class="interactive-chart"></div>
    
    <h2>2. Quantum Gates and Circuits</h2>
    <p>Quantum gates manipulate qubits, enabling the creation of complex quantum circuits. These circuits can model intricate quantum systems across various scales.</p>
    
    <div id="quantum-circuit-simulator" class="interactive-chart"></div>
    
    <h2>3. Entanglement and Non-locality</h2>
    <p>Quantum entanglement, a phenomenon central to quantum computing, provides a unique perspective on non-local interactions in multiscale physical theories.</p>
    
    <div id="entanglement-visualization" class="interactive-chart"></div>
    
    <h2>4. Quantum Algorithms for Multiscale Simulations</h2>
    <p>Specialized quantum algorithms offer unprecedented computational power for simulating complex physical systems across multiple scales.</p>
    
    <div id="algorithm-comparison" class="interactive-chart"></div>
    
    <div class="navigation">
        <a href="bridging-consciousness-and-fundamental-physics.html" class="nav-button">Previous: Introduction</a>
        <a href="string-theory-basics-quantum-perspective.html" class="nav-button">Next: String Theory Basics</a>
    </div>

<script>
// Qubit Bloch Sphere Visualization
function createBlochSphere() {
    const trace = {
        type: "scatter3d",
        mode: "lines",
        x: [],
        y: [],
        z: [],
        line: {color: '#1c4f82', width: 3},
    };

    for (let t = 0; t <= Math.PI; t += 0.01) {
        trace.x.push(Math.sin(t));
        trace.y.push(0);
        trace.z.push(Math.cos(t));
    }

    const layout = {
        title: 'Qubit Bloch Sphere',
        scene: {
            xaxis: {title: 'X'},
            yaxis: {title: 'Y'},
            zaxis: {title: 'Z'}
        }
    };

    Plotly.newPlot('qubit-bloch-sphere', [trace], layout);
}

// Quantum Circuit Simulator
function createQuantumCircuit() {
    const gates = ['H', 'X', 'Y', 'Z', 'CNOT'];
    const qubits = 3;
    const steps = 5;

    const data = [{
        type: 'heatmap',
        z: Array(qubits).fill().map(() => Array(steps).fill(0)),
        text: Array(qubits).fill().map(() => Array(steps).fill('')),
        hoverinfo: 'text',
        colorscale: [
            [0, '#ffffff'],
            [1, '#1c4f82']
        ]
    }];

    for (let i = 0; i < qubits; i++) {
        for (let j = 0; j < steps; j++) {
            const gate = gates[Math.floor(Math.random() * gates.length)];
            data[0].text[i][j] = gate;
            data[0].z[i][j] = gates.indexOf(gate) / (gates.length - 1);
        }
    }

    const layout = {
        title: 'Quantum Circuit Simulator',
        xaxis: {title: 'Time Steps'},
        yaxis: {title: 'Qubits', autorange: 'reversed'}
    };

    Plotly.newPlot('quantum-circuit-simulator', data, layout);
}

// Entanglement Visualization
function createEntanglementVisualization() {
    const trace1 = {
        x: [0, 1],
        y: [0, 1],
        mode: 'lines+markers',
        name: 'Qubit 1',
        line: {color: '#1c4f82'}
    };

    const trace2 = {
        x: [0, 1],
        y: [1, 0],
        mode: 'lines+markers',
        name: 'Qubit 2',
        line: {color: '#82371c'}
    };

    const layout = {
        title: 'Entanglement Visualization',
        xaxis: {title: 'Time'},
        yaxis: {title: 'State'}
    };

    Plotly.newPlot('entanglement-visualization', [trace1, trace2], layout);
}

// Algorithm Comparison
function createAlgorithmComparison() {
    const algorithms = ['Classical', 'Quantum'];
    const problemSizes = [10, 20, 30, 40, 50];
    
    const classicalTime = problemSizes.map(n => Math.pow(2, n));
    const quantumTime = problemSizes.map(n => n * n);

    const trace1 = {
        x: problemSizes,
        y: classicalTime,
        type: 'scatter',
        mode: 'lines+markers',
        name: 'Classical Algorithm'
    };

    const trace2 = {
        x: problemSizes,
        y: quantumTime,
        type: 'scatter',
        mode: 'lines+markers',
        name: 'Quantum Algorithm'
    };

    const layout = {
        title: 'Algorithm Performance Comparison',
        xaxis: {title: 'Problem Size'},
        yaxis: {
            title: 'Computation Time',
            type: 'log'
        }
    };

    Plotly.newPlot('algorithm-comparison', [trace1, trace2], layout);
}

// Initialize all visualizations
document.addEventListener('DOMContentLoaded', (event) => {
    createBlochSphere();
    createQuantumCircuit();
    createEntanglementVisualization();
    createAlgorithmComparison();
});
</script>
</body></html>